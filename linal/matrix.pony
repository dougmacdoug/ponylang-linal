type M2 is (V2, V2)
""" tuple based matrix aliases"""
type M3 is (V3, V3, V3)
type M4 is (V4, V4, V4, V4)
""" tuple based quaternion alias"""

primitive M2fun
  fun apply(r1: V2, r2: V2) : M2 => (r1, r2)
  fun zero() : M2 => ((0,0),(0,0))
  fun id() : M2 => ((1,0),(0,1))
  fun rowx(m: M2) : V2 => m._1
  fun rowy(m: M2) : V2 => m._2
  fun colx(m: M2) : V2 => (m._1._1, m._2._1)
  fun coly(m: M2) : V2 => (m._1._2, m._2._2)
  fun rot(angle: F32) : M2 =>
      let c : F32 = angle.cos()
      let s : F32 = angle.sin()
      ((c, -s), (s, c))
  fun add(a: M2, b: M2) : M2  =>
     ( (a._1._1 + b._1._1, a._1._2 + b._1._2),
       (a._2._1 + b._2._1, a._2._2 + b._2._2) )

  fun sub(a: M2, b: M2) : M2 =>
    ( (a._1._1 - b._1._1, a._1._2 - b._1._2),
      (a._2._1 - b._2._1, a._2._2 - b._2._2) )

  fun neg(a: M2) : M2 =>((-a._1._1, -a._1._2), (-a._2._1, -a._2._2))

  fun mul(a: M2, s: F32) : M2 =>
    ((a._1._1*s, a._1._2*s), (a._2._1*s, a._2._2*s))

  fun div(a: M2, s: F32) : M2 => mul(a, F32(1) / s)

  fun trans(a: M2) : M2 => ((a._1._1, a._2._1), (a._1._2, a._2._2))

  fun mulv2(a: M2, v: V2) : V2 =>
      ( (a._1._1*v._1) + (a._1._2* v._2), (a._2._1*v._1) + (a._2._2*v._2))

  fun mulm2(a: M2, b: M2) : M2 =>
    ( ((a._1._1 * b._1._1) + (a._1._2 * b._2._1),
      (a._1._1 * b._1._2) + (a._1._2 * b._2._2)),
      ((a._2._1 * b._1._1) + (a._2._2 * b._2._1),
      (a._2._1 * b._1._2) + (a._2._2 * b._2._2)) )

   fun trace(m: M2) : F32 => m._1._1 + m._2._2

   fun det(m: M2) : F32 => (m._1._1 * m._2._2) - (m._1._2 * m._2._1)

   fun inv(m: M2) : M2 =>
      let m2 = ((m._2._2, -m._1._2), (-m._2._1, m._1._1))
      div(m2, det(m))

   fun solve(m: M2, v: V2) : V2 =>
     ( (((m._1._2 * v._2) - (m._2._2 * v._1)) / ((m._1._2*m._2._1) - (m._1._1*m._2._2))),
      (((m._2._1 * v._1) - (m._1._1 * v._2)) / ((m._1._2*m._2._1) - (m._1._1*m._2._2))))

   fun eq(a: M2, b: M2, eps: F32 = F32.epsilon()) : Bool =>
     Linear.eq(a._1._1, b._1._1, eps) and
     Linear.eq(a._1._2, b._1._2, eps) and
     Linear.eq(a._2._1, b._2._1, eps) and
     Linear.eq(a._2._2, b._2._2, eps)

primitive M3fun
  fun apply(r1: V3, r2: V3, r3: V3) : M3 => (r1, r2, r3)
  fun zero() : M3 => ((0,0,0),(0,0,0),(0,0,0))
  fun id() : M3 => ((1,0,0),(0,1,0),(0,0,1))
  fun rowx(m: M3) : V3 => m._1
  fun rowy(m: M3) : V3 => m._2
  fun rowz(m: M3) : V3 => m._3
  fun colx(m: M3) : V3 => (m._1._1, m._2._1, m._3._1)
  fun coly(m: M3) : V3 => (m._1._2, m._2._2, m._3._2)
  fun colz(m: M3) : V3 => (m._1._3, m._2._3, m._3._3)

  fun rotx(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((1, 0, 0), (0, c, -s), (0, s, c))
  fun roty(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((c, 0, s), (0, 1, 0), (-s, 0, c))
  fun rotz(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((c, -s, 0), (s, c, 0), (0, 0, 1))

   fun add(a: M3, b: M3) : M3 =>
      ( (a._1._1 + b._1._1, a._1._2 + b._1._2, a._1._3 + b._1._3),
        (a._2._1 + b._2._1, a._2._2 + b._2._2, a._2._3 + b._2._3),
        (a._3._1 + b._3._1, a._3._2 + b._3._2, a._3._3 + b._3._3))

   fun sub(a: M3, b: M3)  : M3 =>
     ( (a._1._1 - b._1._1, a._1._2 - b._1._2, a._1._3 - b._1._3),
       (a._2._1 - b._2._1, a._2._2 - b._2._2, a._2._3 - b._2._3),
       (a._3._1 - b._3._1, a._3._2 - b._3._2, a._3._3 - b._3._3))

   fun neg(a: M3) : M3 =>
     ( (-a._1._1, -a._1._2, -a._1._3),
       (-a._2._1, -a._2._2, -a._2._3),
       (-a._3._1, -a._3._2, -a._3._3) )

   fun mul(a: M3, s: F32) : M3 =>
     ( (a._1._1*s, a._1._2*s, a._1._3*s),
       (a._2._1*s, a._2._2*s, a._2._3*s),
       (a._3._1*s, a._3._2*s, a._3._3*s) )

   fun div(a: M3, s: F32) : M3 => mul(a, F32(1)/s)

   fun trans(a: M3) : M3 =>
      ((a._1._1, a._2._1, a._3._1),
       (a._1._2, a._2._2, a._3._2),
       (a._1._3, a._2._3, a._3._3))

   fun mulv3(a: M3, v: V3) : V3 =>
       ((a._1._1 * v._1) + (a._1._2 * v._2) + (a._1._3 * v._3),
        (a._2._1 * v._1) + (a._2._2 * v._2) + (a._2._3 * v._3),
        (a._3._1 * v._1) + (a._3._2 * v._2) + (a._3._3 * v._3))

   fun mulm3(a: M3, b: M3) : M3 =>
     (((a._1._1 * b._1._1) + (a._1._2 * b._2._1) + (a._1._3 * b._3._1),
       (a._1._1 * b._1._2) + (a._1._2 * b._2._2) + (a._1._3 * b._3._2),
       (a._1._1 * b._1._3) + (a._1._2 * b._2._3) + (a._1._3 * b._3._3)),
      ((a._2._1 * b._1._1) + (a._2._2 * b._2._1) + (a._2._3 * b._3._1),
       (a._2._1 * b._1._2) + (a._2._2 * b._2._2) + (a._2._3 * b._3._2),
       (a._2._1 * b._1._3) + (a._2._2 * b._2._3) + (a._2._3 * b._3._3)),
      ((a._3._1 * b._1._1) + (a._3._2 * b._2._1) + (a._3._3 * b._3._1),
       (a._3._1 * b._1._2) + (a._3._2 * b._2._2) + (a._3._3 * b._3._2),
       (a._3._1 * b._1._3) + (a._3._2 * b._2._3) + (a._3._3 * b._3._3)))

    fun trace(m: M3) : F32 => m._1._1 + m._2._2 + m._3._3

    fun det(m: M3) : F32 =>
       (m._1._1 * m._2._2 * m._3._3) +
       (m._1._2 * m._2._3 * m._3._1) +
      ((m._2._1 * m._3._2 * m._1._3) -
       (m._1._3 * m._2._2 * m._3._1) -
       (m._1._1 * m._2._3 * m._3._2) -
       (m._1._2 * m._2._1 * m._3._3))

    fun inv(m: M3) : M3 =>
      let d =  det(m)
      if d == 0 then zero() else
      ((((m._2._2 * m._3._3) - (m._2._3 * m._3._2)) / d,
        ((m._3._2 * m._1._3) - (m._3._3 * m._1._2)) / d,
        ((m._1._2 * m._2._3) - (m._1._3 * m._2._2)) / d),
       (((m._2._3 * m._3._1) - (m._2._1 * m._3._3)) / d,
        ((m._3._3 * m._1._1) - (m._3._1 * m._1._3)) / d,
        ((m._1._3 * m._2._1) - (m._1._1 * m._2._3)) / d),
       (((m._2._1 * m._3._2) - (m._2._2 * m._3._1)) / d,
        ((m._3._1 * m._1._2) - (m._3._2 * m._1._1)) / d,
        ((m._1._1 * m._2._2) - (m._1._2 * m._2._1)) / d))
      end

    fun solve(m: M3, v: V3) : V3 =>
      let d  = det(m)
      let dx = det(((v._1,m._1._2,m._1._3),(v._2,m._2._2,m._2._3),(v._3,m._3._2,m._3._3)))
      let dy = det(((m._1._1,v._1,m._1._3),(m._2._1,v._2,m._2._3),(m._3._1,v._3,m._3._3)))
      let dz = det(((m._1._1,m._1._2,v._1),(m._2._1,m._2._2,v._2),(m._3._1,m._3._2,v._3)))
      (dx/d, dy/d, dz/d)

    fun eq(a: M3, b: M3, eps: F32 = F32.epsilon()) : Bool =>
      Linear.eq(a._1._1, b._1._1, eps) and
      Linear.eq(a._1._2, b._1._2, eps) and
      Linear.eq(a._1._3, b._1._3, eps) and
      Linear.eq(a._2._1, b._2._1, eps) and
      Linear.eq(a._2._2, b._2._2, eps) and
      Linear.eq(a._2._3, b._2._3, eps) and
      Linear.eq(a._3._1, b._3._1, eps) and
      Linear.eq(a._3._2, b._3._2, eps) and
      Linear.eq(a._3._3, b._3._3, eps)

primitive M4fun
  fun apply(r1: V4, r2: V4, r3: V4, r4: V4) : M4 => (r1, r2, r3, r4)
  fun zero() : M4 => ((0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0))
  fun id() : M4 => ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
  fun rowx(m: M4) : V4 => m._1
  fun rowy(m: M4) : V4 => m._2
  fun rowz(m: M4) : V4 => m._3
  fun roww(m: M4) : V4 => m._4
  fun colx(m: M4) : V4 => (m._1._1, m._2._1, m._3._1, m._4._1)
  fun coly(m: M4) : V4 => (m._1._2, m._2._2, m._3._2, m._4._2)
  fun colz(m: M4) : V4 => (m._1._3, m._2._3, m._3._3, m._4._3)
  fun colw(m: M4) : V4 => (m._1._4, m._2._4, m._3._4, m._4._4)

  // fun rotx(angle: F32) : M4 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((1, 0, 0), (0, c, -s), (0, s, c))
  // fun roty(angle: F32) : M3 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((c, 0, s), (0, 1, 0), (-s, 0, c))
  // fun rotz(angle: F32) : M3 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((c, -s, 0), (s, c, 0), (0, 0, 1))

   fun add(a: M4, b: M4) : M4 =>
      ( (a._1._1 + b._1._1,  a._1._2 + b._1._2,
                   a._1._3 + b._1._3,  a._1._4 + b._1._4),
        (a._2._1 + b._2._1,  a._2._2 + b._2._2,
                   a._2._3 + b._2._3,  a._2._4 + b._2._4),
        (a._3._1 + b._3._1,  a._3._2 + b._3._2,
                   a._3._3 + b._3._3,  a._3._4 + b._3._4),
        (a._4._1 + b._4._1,  a._4._2 + b._4._2,
                   a._4._3 + b._4._3,  a._4._4 + b._4._4))

   fun sub(a: M4, b: M4) : M4 =>
      ( (a._1._1 - b._1._1,  a._1._2 - b._1._2,
                   a._1._3 - b._1._3,  a._1._4 - b._1._4),
        (a._2._1 - b._2._1,  a._2._2 - b._2._2,
                   a._2._3 - b._2._3,  a._2._4 - b._2._4),
        (a._3._1 - b._3._1,  a._3._2 - b._3._2,
                   a._3._3 - b._3._3,  a._3._4 - b._3._4),
        (a._4._1 - b._4._1,  a._4._2 - b._4._2,
                   a._4._3 - b._4._3,  a._4._4 - b._4._4))

   fun neg(a: M4) : M4 =>
     ( (-a._1._1, -a._1._2, -a._1._3, -a._1._4),
       (-a._2._1, -a._2._2, -a._2._3, -a._2._4),
       (-a._3._1, -a._3._2, -a._3._3, -a._3._4),
       (-a._4._1, -a._4._2, -a._4._3, -a._4._4) )

    fun mul(a: M4, s: F32) : M4 =>
     ( (a._1._1*s, a._1._2*s, a._1._3*s, a._1._4*s),
       (a._2._1*s, a._2._2*s, a._2._3*s, a._2._4*s),
       (a._3._1*s, a._3._2*s, a._3._3*s, a._3._4*s),
       (a._4._1*s, a._4._2*s, a._4._3*s, a._4._4*s) )

    fun div(a: M4, s: F32) : M4 => mul(a, F32(1)/s)

    fun trans(a: M4) : M4 =>
      ((a._1._1, a._2._1, a._3._1, a._4._1),
       (a._1._2, a._2._2, a._3._2, a._4._2),
       (a._1._3, a._2._3, a._3._3, a._4._3),
       (a._1._4, a._2._4, a._3._4, a._4._4))

    fun v3trans(v : V3) : M4 => 
      ((1,0,0,v._1),
      (0,1,0,v._2),
      (0,0,1,v._3),
      (0,0,0,1))
  
    fun v3scale(m: M4, v: V3) : M4 =>
      ((v._1,     0,   0, 0),
       (   0,  v._2,   0, 0),
       (   0,     0,v._3, 0),
       (   0,     0,   0, 1))

    fun v3mul(a: M4, v: V3) : V3 =>
      ( (a._1._1 * v._1) + (a._1._2 * v._2) + (a._1._3 * v._3),
        (a._2._1 * v._1) + (a._2._2 * v._2) + (a._2._3 * v._3),
        (a._3._1 * v._1) + (a._3._2 * v._2) + (a._3._3 * v._3))

    fun v3mul_point_3x4(a: M4, v: V3) : V3 =>
      ( (a._1._1 * v._1) + (a._1._2 * v._2) + (a._1._3 * v._3) + a._1._4,
        (a._2._1 * v._1) + (a._2._2 * v._2) + (a._2._3 * v._3) + a._2._4,
        (a._3._1 * v._1) + (a._3._2 * v._2) + (a._3._3 * v._3) + a._3._4)

    fun v3mul_point(a: M4, v: V3) : V3 =>
      let v3 = v3mul_point_3x4(a, v)
      let n  = (a._4._1 * v._1) + (a._4._2 * v._2) + (a._4._3 * v._3) + a._4._4
      let n' = 1/n
      V3fun.mul(v3, n')


    fun v4mul(a: M4, v: V4) : V4 =>
      ( (a._1._1 * v._1) + (a._1._2 * v._2) 
        + (a._1._3 * v._3) + (a._1._4 * v._4),

        (a._2._1 * v._1) + (a._2._2 * v._2) +
         (a._2._3 * v._3) + (a._2._4 * v._4),

        (a._3._1 * v._1) + (a._3._2 * v._2) +
         (a._3._3 * v._3) + (a._3._4 * v._4),

        (a._4._1 * v._1) + (a._4._2 * v._2) +
         (a._4._3 * v._3) + (a._4._4 * v._4))



   // fun mulm3(a: M3, b: M3) : M3 =>
   //   (((a._1._1 * b._1._1) + (a._1._2 * b._2._1) + (a._1._3 * b._3._1),
   //     (a._1._1 * b._1._2) + (a._1._2 * b._2._2) + (a._1._3 * b._3._2),
   //     (a._1._1 * b._1._3) + (a._1._2 * b._2._3) + (a._1._3 * b._3._3)),
   //    ((a._2._1 * b._1._1) + (a._2._2 * b._2._1) + (a._2._3 * b._3._1),
   //     (a._2._1 * b._1._2) + (a._2._2 * b._2._2) + (a._2._3 * b._3._2),
   //     (a._2._1 * b._1._3) + (a._2._2 * b._2._3) + (a._2._3 * b._3._3)),
   //    ((a._3._1 * b._1._1) + (a._3._2 * b._2._1) + (a._3._3 * b._3._1),
   //     (a._3._1 * b._1._2) + (a._3._2 * b._2._2) + (a._3._3 * b._3._2),
   //     (a._3._1 * b._1._3) + (a._3._2 * b._2._3) + (a._3._3 * b._3._3)))

    fun trace(m: M4) : F32 => m._1._1 + m._2._2 + m._3._3 + m._4._4

   //  fun det(m: M3) : F32 =>
   //     (m._1._1 * m._2._2 * m._3._3) +
   //     (m._1._2 * m._2._3 * m._3._1) +
   //    ((m._2._1 * m._3._2 * m._1._3) -
   //     (m._1._3 * m._2._2 * m._3._1) -
   //     (m._1._1 * m._2._3 * m._3._2) -
   //     (m._1._2 * m._2._1 * m._3._3))

   //  fun inv(m: M3) : M3 =>
   //    let d =  det(m)
   //    if d == 0 then zero() else
   //    ((((m._2._2 * m._3._3) - (m._2._3 * m._3._2)) / d,
   //      ((m._3._2 * m._1._3) - (m._3._3 * m._1._2)) / d,
   //      ((m._1._2 * m._2._3) - (m._1._3 * m._2._2)) / d),
   //     (((m._2._3 * m._3._1) - (m._2._1 * m._3._3)) / d,
   //      ((m._3._3 * m._1._1) - (m._3._1 * m._1._3)) / d,
   //      ((m._1._3 * m._2._1) - (m._1._1 * m._2._3)) / d),
   //     (((m._2._1 * m._3._2) - (m._2._2 * m._3._1)) / d,
   //      ((m._3._1 * m._1._2) - (m._3._2 * m._1._1)) / d,
   //      ((m._1._1 * m._2._2) - (m._1._2 * m._2._1)) / d))
   //    end

   //  fun solve(m: M3, v: V3) : V3 =>
   //    let d  = det(m)
   //    let dx = det(((v._1,m._1._2,m._1._3),(v._2,m._2._2,m._2._3),(v._3,m._3._2,m._3._3)))
   //    let dy = det(((m._1._1,v._1,m._1._3),(m._2._1,v._2,m._2._3),(m._3._1,v._3,m._3._3)))
   //    let dz = det(((m._1._1,m._1._2,v._1),(m._2._1,m._2._2,v._2),(m._3._1,m._3._2,v._3)))
   //    (dx/d, dy/d, dz/d)

    fun eq(a: M4, b: M4, eps: F32 = F32.epsilon()) : Bool =>
      Linear.eq(a._1._1, b._1._1, eps) and
      Linear.eq(a._1._2, b._1._2, eps) and
      Linear.eq(a._1._3, b._1._3, eps) and
      Linear.eq(a._1._4, b._1._4, eps) and
      Linear.eq(a._2._1, b._2._1, eps) and
      Linear.eq(a._2._2, b._2._2, eps) and
      Linear.eq(a._2._3, b._2._3, eps) and
      Linear.eq(a._2._4, b._2._4, eps) and
      Linear.eq(a._3._1, b._3._1, eps) and
      Linear.eq(a._3._2, b._3._2, eps) and
      Linear.eq(a._3._3, b._3._3, eps) and
      Linear.eq(a._3._4, b._3._4, eps) and
      Linear.eq(a._4._1, b._4._1, eps) and
      Linear.eq(a._4._2, b._4._2, eps) and
      Linear.eq(a._4._3, b._4._3, eps) and
      Linear.eq(a._4._4, b._4._4, eps)

// @todo
// fix this .. used wrong coords [flipped] 
    // fun rot(m: M4, q: Q4) : M4 =>
    //   let n1  : F32  = q._1 * 2
    //   let n2  : F32  = q._2 * 2
    //   let n3  : F32  = q._3 * 2
    //   let n4  : F32  = q._1 * n1
    //   let n5  : F32  = q._2 * n2
    //   let n6  : F32  = q._3 * n3
    //   let n7  : F32  = q._1 * n2
    //   let n8  : F32  = q._1 * n3
    //   let n9  : F32  = q._2 * n3
    //   let n10 : F32  = q._4 * n1
    //   let n11 : F32  = q._4 * n2
    //   let n12 : F32  = q._4 * n3

    //   (((1 - (n5 + n6)), n7 + n12, n8 - n11, 0),
    //     (n7 - n12, (1 - (n4 + n6)), n9 + n10, 0),
    //     (n8 + n11, n9 - n10, (1 - (n4 + n5)), 0),
    //     (0, 0, 0, 1))
